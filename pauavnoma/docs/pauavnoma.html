<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pauavnoma API documentation</title>
<meta name="description" content="Numerical Simulation of Power allocation in UAV-NOMA System â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pauavnoma</code></h1>
</header>
<section id="section-intro">
<p>Numerical Simulation of Power allocation in UAV-NOMA System.</p>
<p>A Python 3.9 implementation of a model of wireless communication
system between an area base station and two users.
Initially, power allocation is employed manually.</p>
<p>This application can be used as a study tool to understand the
behavior of the achievable rate by two users and the influence
of the allocation of power coefficients in a UAV-NOMA system.
The communication model presented is a base of UAV-NOMA principles and
can be expanded to several other scenarios, such as massive MIMO,
full-duplex communication, and others in order to
improve the users' rate performance.</p>
<p>The user can modify parameters and analyze the system's behavior.
Based on this, new methods can be proposed to solve trajectory problems,
power allocation, decoding order and others.</p>
<p>Example: when the Rician Factor <code>K=0</code>, fading is similar to Rayleigh's.</p>
<hr>
<h3 id="requirement">Requirement</h3>
<p>The implementation requires Python 3.6+ to run.
The following libraries are required:</p>
<ul>
<li><code>numpy</code> </li>
<li><code>matplotlib.pyplot</code></li>
<li><code>math</code></li>
<li><code>random</code></li>
</ul>
<hr>
<h2 id="description-of-the-simulation-parameters">Description of the Simulation Parameters</h2>
<ul>
<li><code>N_mc</code> (integer) : Monte Carlo Samples.</li>
<li><code>N_users</code> (integer) : number of users (in our case, two users).</li>
<li><code>M_uav</code>(integer) : number of UAV
(in our case, single uav).</li>
<li><code>snr_dB</code> (array of integer, size[10:2:51]) : signal-to-noise ratio in dB.</li>
<li><code>path_loss_exp</code> (integer) : path loss exponent.</li>
<li><code>P_los</code> (float) : total power of LOS path &amp; scattered paths.</li>
<li><code>K</code> (integer) : Rician Factor.</li>
<li><code>target_rate_primary_user</code> (float) : target rate in bits/s/Hertz of primary users. </li>
<li><code>target_rate_secondary_user</code> (float) : target rate in bits/s/Hertz of secondary users. </li>
<li><code>radius_uav</code> (float) : radius in meter of fly trajectory UAV.</li>
<li><code>radius_user</code> (float) : radius of the cell of users in meters.</li>
<li><code>uav_heigth</code>(float) : UAV height.</li>
<li><code>distance</code>(array of float, size(N_users)) : distance between UAV and n-th user randomly calculated for each Monte Carlo sample. </li>
<li><code>powerCoeffPrimary</code> (float) : power coefficient allocated to the Primary user.</li>
<li><code>powerCoeffSecondary</code> (float) : power coefficient allocated to the Secondary user.</li>
<li><code>ch_coeff</code> (complex number) : channel coefficients for each user generated by Rician distribution. This can be generated randomly following
using: <code>ch_coeff=np.sqrt((np.random.normal(s,sigma)**2) + 1j*(np.random.normal(0,sigma)**2))</code>.</li>
<li><code>s</code> (float) : Non-Centrality Parameter (mean) of Rician distribution, obtained by <code>s=sqrt(K/(K+1)*P_los)</code>.</li>
<li><code>sigma</code> (float) : Standard deviation of Rician distribution, obtained by <code>sigma = P_los/sqrt(2*(K+1))</code>.</li>
<li><code>h_n</code> (array of float, size(N_users)) : channel coefficients over distance effects.</li>
<li><code>channelGain</code> (array of float, size(N_users)) : channel gain <code>abs(h_n)^2</code> sorted in descending order (primary user &gt; secondary user).</li>
</ul>
<hr>
<h2 id="performance-analysis-metrics">Performance analysis metrics</h2>
<ul>
<li>
<p><code>Outage Probability:</code> the outage probability is estimated as the ratio between the number of outage events and
the total number of Monte Carlo repetitions. An outage event happens when the supported user data rates for a particular
instantaneous channel realization is less than the target data rate. </p>
</li>
<li>
<p><code>Achievable Rate:</code> the achievable rate consists of the throughput of network users, while average achievable rate
consists of the average throughput of all network users.</p>
</li>
</ul>
<p>To plot the figures, the comments at the beginning of the Figures section must be removed from the code.
</p>
<hr>
<h2 id="adaptive-algorithm-description">Adaptive Algorithm description</h2>
<p>Adaptive power allocation algorithm was not implemented in the present version.</p>
<hr>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

&#39;&#39;&#39; 
   Numerical Simulation of Power allocation in UAV-NOMA System.
   
   A Python 3.9 implementation of a model of wireless communication 
   system between an area base station and two users. 
   Initially, power allocation is employed manually.

   .. include:: ./documentation.md

&#39;&#39;&#39;

import random
import numpy as np
from numpy import sqrt
import matplotlib.pyplot as plt
import math



# --------------- Paramenters ---------------
def parameters():
   &#39;&#39;&#39;Returns the simulation parameters.

      Enter values for each requested parameter. The entered 
      values are tested to check if the parameters are viable.
   &#39;&#39;&#39;
   samples_mc = 10000 # Monte Carlo samples
   print(&#34;The greater the number of samples, the more computational time is required.&#34;)
   assert 10000&lt;=samples_mc &lt;= 1000000, &#34;Invalid quantity, the value entered must be 10000&lt;=samples_mc &lt;= 1000000.&#34;

   number_users =2
   assert number_users == 2, &#34;Number of users must be 2.&#34;  

   power_los = 1.0
   assert power_los == 1.0 or power_los == 2.0,  &#34;Invalid power of Line-of-Sigth path &amp; scattered paths.&#34;
 
   rician_factor = 6 
   assert rician_factor&gt;=0 and rician_factor &lt;=10, &#34;Invalid Rician factor, the value must be (0&lt;= value &lt;= 10)&#34;
   

   path_loss_value = 2 # Path loss exponent
   number_uav = 1      # Number of UAVs
   assert number_uav == 1, &#34;Number of UAV must be 1.&#34; 

   radius_value_uav = 1.0 # Fly trajectory of the UAV in meters
   radius_value_user= 2.0 # Distribution radius of users in the cell in meters.
   # Users&#39; Target Rate
   rate_value_primary_user = 1.0  # Target rate bits/s/Hertz  primary user
   rate_value_secondary_user = 0.5  # Target rate bits/s/Hertz  secondary users
   snr_values_dB = np.array(range(10, 51, 2))  # SNR in dB
   snr_values_linear = 10**(snr_values_dB/10)  # SNR linear

   return samples_mc, number_users, power_los, rician_factor, path_loss_value, number_uav, snr_values_dB, snr_values_linear, radius_value_uav, radius_value_user, rate_value_primary_user, rate_value_secondary_user


def generate_power_Coeff(n_users):
   &#39;&#39;&#39;Returns the power coefficient allocation of the users.
     Arguments:

         n_user -- number of users. 
    Return:   

         data_power_Pri --  power coefficients of the Primary users.
         data_power_Sec --  power coefficients of the Secondary users.
   &#39;&#39;&#39;

   print(&#39;WARNING: The sum of powers must be: [0 &lt;sum(power) &lt;= 1], \n AND the power of the primary user must be greater than that of the secondary in order for their QoS to be satisfied. E.g. user_1 = 0.8 and user_2 =0.2.\n&#39;)
   #(&#39;Enter the value of power coefficient allocation of the Primary User:  &#39;)
   data_power_Pri = 0.8 #float(input(&#39;--&gt; &#39;))
  # (&#39;Enter the value of power coefficient allocation of the Secondart User:  &#39;)
   data_power_Sec = 0.2 #float(input(&#39;--&gt; &#39;))
      
   return data_power_Pri, data_power_Sec


N_mc, N_users, P_los, K, path_loss_exp, M_uav, snr_dB, snr_linear, radius_uav,  radius_user, target_rate_primary_user, target_rate_secondary_user = parameters()
powerCoeffPrimary, powerCoeffSecondary = generate_power_Coeff(N_users) 

# Fading modeled by Rician distribution
s=np.sqrt(K/(K+1)*P_los) # Non-Centrality Parameter (mean)
sigma=P_los/np.sqrt(2*(K+1)) # Standard deviation


# Initialization of some arrays
out_probability= np.zeros((N_mc,len(snr_dB),N_users))
out_probability_system = np.zeros((N_mc,len(snr_dB)))
out_probability_secondary_user = np.zeros((N_mc,len(snr_dB)))
out_probability_primary_user = np.zeros((N_mc,len(snr_dB)))
average_rate = np.zeros((N_mc,len(snr_dB)))
instantaneous_rate_secondary = np.zeros((N_mc,len(snr_dB)))
instantaneous_rate_primary = np.zeros((N_mc,len(snr_dB)))

#------------------------------------------------------------------------------------

for mc in range(N_mc):

   def random_Position_UAV(numberUAV, radiusUAV):
      &#39;&#39;&#39; Returns a random UAV position based on 3D Cartesian coordinates.

                x_r: x-axis | y_r: y-axis | z_r: heigth

       `theta_r:` randomly generates an angle  

       `rho_r:` radius in meter of fly trajectory UAV


       `rho_u:` radius in meter of the area where users are distributed

        Arguments:

            umberUAV -- number of UAV.
            radiusUAV -- fly trajectory of the UAV in meters. 
       Return:   

            x_r, y_r, z_r -- position in the x-axis, y-axis and heigth of the UAV.
     &#39;&#39;&#39;
      theta_r = (np.random.rand(numberUAV,1)*(math.pi*2))
      rho_r = radiusUAV
      x_r =  (rho_r*np.cos(theta_r))
      y_r =  (rho_r*np.sin(theta_r))
      z_r = 30.0
      return x_r, y_r, z_r     

   def random_Position_Users(numberUsers, radiusUser):
      &#39;&#39;&#39; Returns a random ground users position based on 2D Cartesian coordinates. 

               x_u: x-axis |  y_u: y-axis | height is not considered

       `theta_u:` randomly generates an angle  

       `rho_u:` radius in meter of the area where users are distributed

        Arguments:

            numberUsers -- number of users.
            radiusUser -- distribution radius of users in the cell in meters.
       Return:   

            x_u, y_u -- position in the x-axis and y-axis of the n-th user.  

      &#39;&#39;&#39;
      theta_u = (np.random.rand(numberUsers,1))*(math.pi*2)
      rho_u = (np.sqrt(np.random.rand(numberUsers,1))*radiusUser)
      x_u = (rho_u*np.cos(theta_u))
      y_u = (rho_u*np.sin(theta_u))
      return x_u, y_u  

   uav_AxisX, uav_AxisY, uav_heigth = random_Position_UAV(M_uav,radius_uav)
   user_AxisX, user_AxisY = random_Position_Users(N_users,radius_user)

   # Initializing auxiliary arrays to store channel coefficients and distance between UAV and users, respectively:
   h_n = np.zeros(N_users)
   distance = np.zeros(N_users)


   def generate_Channel(s,sigma,numberUser,user_X, user_Y, uav_X, uav_Y, path_loss, uav_Z):
     &#39;&#39;&#39;Returns the sorting channel gains of the users over Rician Fading. The channel gains are sorted to identify
        the primary user and secondary user.

        `ch_coeff:` calculating channel coefficients with Random Variable Rice of mean=s and variance=sigma.

        `distance:` calculating distance between UAV and users.

        `h_n:` calculates channel coefficients based on the distance.

         `channelGain:` calculates the channel gains and sorting in descending order.

                     Primary user:  channelGain[0]   -&gt; max value

                     Secondary user:  channelGain[1] -&gt; min value    

        Arguments:

            s -- non-Centrality Parameter (mean).
            sigma -- standard deviation.
            numberUser -- number of user.
            user_X -- position axis x of n-th user.
            user_Y -- position axis y of n-th user.
            uav_X -- position axis x of UAV.
            uav_Y -- position axis y of UAV.
            path_loss -- path loss exponent.
            uav_z -- UAV heigth.
       Return:   

            channelGain -- sorted channel gain of the users.             
       
     &#39;&#39;&#39;
     for uu in range(numberUser):  

         ch_coeff = np.sqrt( (np.random.normal(s,sigma)**2) + 1j*(np.random.normal(0,sigma)**2) )
         distance[uu]= np.sqrt( (user_X[uu]-uav_X)**2  + (user_Y[uu]-uav_Y)**2   + uav_Z**2  )
         h_n[uu] = np.abs(ch_coeff/np.complex(sqrt(1+(distance[uu])**path_loss),0))**2

     channelGain = sorted(h_n, reverse=True)
     return channelGain  

   channelGainPrimary = np.max(generate_Channel(s,sigma,N_users,user_AxisX, user_AxisY, uav_AxisX, uav_AxisY, path_loss_exp, uav_heigth))
   channelGainSecondary = np.min(generate_Channel(s,sigma,N_users,user_AxisX, user_AxisY, uav_AxisX, uav_AxisY, path_loss_exp, uav_heigth))
      
   &#39;&#39;&#39; Initializating auxiliary arrays of: 

      Signal-to-interference-plus-noise ratio experienced by the primary user.

      Signal-to-interference-plus-noise ratio experienced by the secondary user.
   &#39;&#39;&#39;    
   sinr_primary= np.zeros((len(snr_dB))) 
   sinr_secondary = np.zeros((len(snr_dB))) 
   inst_rate_primary = np.zeros((len(snr_dB))) 
   inst_rate_secondary = np.zeros((len(snr_dB))) 

   def calculate_Instantaneous_Rate_Primary(channelPri,channelSec,snrValuesdB,powerPrimary,powerSecondary,target_RatePri):
      &#39;&#39;&#39;Returns the instantaneous achievable rate of the primary user for all values of SNR in dB.

         `sinr_primary:` generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the primary user based on NOMA.

         `inst_rate_primary:` calculates instantaneous rate of the primary user based on sinr_primary.

               If the calculated instantaneous rate does not reach the rate desired by the user, OMA is used in order to guarantee 
               the Quality-of-Service requirements. 
 
        Arguments:

            channelPri -- channel gain of the primary user
            channelSec -- channel gain of the secondary user.
            snrValuesdB -- SNR values in dB.
            powerPrimary --  power coefficient allocated to the Primary user.
            powerSecondary --  power coefficient allocated to the Secondary user.
            target_RatePri -- target rate of the primary user.
       Return:   
            
            inst_rate_primary -- instantaneous achievable rate of the primary user.
      &#39;&#39;&#39;
      for sn in range(0,len(snrValuesdB)):    

         sinr_primary[sn] = (snr_linear[sn]*channelPri*powerPrimary) / (snr_linear[sn]*channelSec*powerSecondary  + 1)
         inst_rate_primary[sn] = np.log(1+sinr_primary[sn]) # Instantaneous achievable rate of primary user NOMA

         if inst_rate_primary[sn] &lt; target_RatePri: 
            sinr_primary[sn] = (snr_linear[sn]*channelPri)
            inst_rate_primary[sn] = 0.5*np.log(1+sinr_primary[sn]) # Instantaneous achievable rate of primary user OMA
      return inst_rate_primary

   def calculate_Instantaneous_Rate_Secondary(channelSec,snrValues,powerSecondary):
      &#39;&#39;&#39;Returns the instantaneous achievable rate of the secondary user for all values of SNR in dB.

         `sinr_secondary:` generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the secondary user based on NOMA.

         `inst_rate_secondary:` calculates instantaneous rate of the secondary user based on sinr_secondary.
 
 
        Arguments:

            channelSec -- channel gain of the secondary user.
            snrValues -- SNR values in dB.
            powerSecondary --  power coefficient allocated to the Secondary user.
       Return:   
            
            inst_rate_secondary -- instantaneous achievable rate of the secondary user.   
      &#39;&#39;&#39;

      for sn in range(0,len(snrValues)):    
         sinr_secondary[sn] = (snr_linear[sn]*channelSec*powerSecondary)
         inst_rate_secondary[sn] = np.log(1+sinr_secondary[sn]) # Instantaneous achievable rate of secondary user

      return inst_rate_secondary

   instantaneous_rate_primary[mc,:] = calculate_Instantaneous_Rate_Primary(channelGainPrimary, channelGainSecondary, snr_dB, powerCoeffPrimary, powerCoeffSecondary, target_rate_primary_user)
   instantaneous_rate_secondary[mc,:] = calculate_Instantaneous_Rate_Secondary(channelGainSecondary, snr_dB, powerCoeffSecondary)
  
    
   for sn in range(0,len(snr_dB)):  
      # Calculating of outage probability of the system
      if (instantaneous_rate_primary[mc,sn]  &lt; target_rate_primary_user) or (instantaneous_rate_secondary[mc,sn]  &lt; target_rate_secondary_user) :
         out_probability_system[mc,sn] = 1
      else:
         out_probability_system[mc,sn] = 0      

      # Calculating of outage probability of the primary user
      if (instantaneous_rate_primary[mc,sn]  &lt; target_rate_primary_user):
         out_probability_primary_user[mc,sn] = 1
      else: 
         out_probability_primary_user[mc,sn] = 0

      # Calculating of outage probability of the secondary user
      if (instantaneous_rate_secondary[mc,sn]  &lt; target_rate_secondary_user):
         out_probability_secondary_user[mc,sn] = 1
      else: 
         out_probability_secondary_user[mc,sn] = 0

      # Calculating of average achievable rate  of the system
      average_rate[mc,sn] = (instantaneous_rate_primary[mc,sn]+instantaneous_rate_secondary[mc,sn])/2 # Average achievable rate in bits/s/Hz

#------- FIGURES --------


# Outage Probability 

out_prob_mean = np.mean(out_probability_system, axis=0) # Outage probability of the System
out_prob_primary = np.mean(out_probability_primary_user, axis=0) # Outage probability of the Primary User
out_prob_secondary = np.mean(out_probability_secondary_user, axis=0) # Outage probability of the Secondary User
print(&#39;Outage probability system:&#39;, out_prob_mean)

#Saving outage probability values in .txt
#print(&#39;Outage probability system:&#39;, out_prob_mean, &#39;\n\nOutage probability primary user:&#39;, out_prob_primary, &#39;\n\nOutage probability secondary user:&#39;, out_prob_secondary, file=open(&#34;pa-uav-noma/outage_prob_values.txt&#34;, &#34;w&#34;))


# Achievable Rate 
average_rate_mean = np.mean(average_rate, axis=0) # Average achievable rate of the system
rate_mean_primary_user = np.mean(instantaneous_rate_primary, axis=0) # Average achievable rate of the Primary User
rate_mean_secondary_user = np.mean(instantaneous_rate_secondary, axis=0) # Average achievable rate of the Secondary User
print(&#39;Average Achievable Rate of the System:&#39;, average_rate_mean)


# Saving achievable rate values in .txt
#print(&#39; Average Achievable Rate of the System:&#39;, average_rate_mean, &#39;\n\nAverage achievable rate of the Primary User:&#39;, rate_mean_primary_user, &#39;\n\nAverage achievable rate of the Secondary User:&#39;, rate_mean_secondary_user, file=open(&#34;pa-uav-noma/achievable_rate_values.txt&#34;, &#34;w&#34;))

# To plot the figures, the comments below need to be removed.
&#39;&#39;&#39;

plt.semilogy(snr_dB, out_prob_mean, &#39;go-&#39;, label=&#34;System&#34;, linewidth=2)
plt.semilogy(snr_dB, out_prob_primary, &#39;b.-&#39;, label=&#34;Primary user&#34;, linewidth=1)
plt.semilogy(snr_dB, out_prob_secondary, &#39;r.-&#39;, label=&#34;Secondary user&#34;, linewidth=1)
plt.xlabel(&#39;SNR (dB)&#39;)
plt.ylabel(&#39;Outage Probability&#39;)
plt.legend(loc=&#34;lower left&#34;)
plt.xlim(10,50)




# Average Achievable Rate 

plt.figure()
plt.plot(snr_dB, average_rate_mean, &#39;r.-&#39;, label=&#34;Fixed PA&#34;, linewidth=2)
plt.xlim(10,50)
plt.xlabel(&#39;SNR (dB)&#39;)
plt.ylabel(&#39;Average achievable rate (bits/s/Hz)&#39;)
plt.legend(loc=&#34;upper left&#34;)


plt.figure()
plt.plot(snr_dB, rate_mean_primary_user, &#39;b.-&#39;, label=&#34;primary user&#34;, linewidth=1)
plt.plot(snr_dB, rate_mean_secondary_user, &#39;r.-&#39;, label=&#34;secondary user&#34;, linewidth=1)
plt.xlim(10,50)
plt.xlabel(&#39;SNR (dB)&#39;)
plt.ylabel(&#39;Achievable rate (bits/s/Hz)&#39;)
plt.legend(loc=&#34;upper left&#34;)


plt.show()

&#39;&#39;&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pauavnoma.calculate_Instantaneous_Rate_Primary"><code class="name flex">
<span>def <span class="ident">calculate_Instantaneous_Rate_Primary</span></span>(<span>channelPri, channelSec, snrValuesdB, powerPrimary, powerSecondary, target_RatePri)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the instantaneous achievable rate of the primary user for all values of SNR in dB.</p>
<p><code>sinr_primary:</code> generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the primary user based on NOMA.</p>
<p><code>inst_rate_primary:</code> calculates instantaneous rate of the primary user based on sinr_primary.</p>
<pre><code>    If the calculated instantaneous rate does not reach the rate desired by the user, OMA is used in order to guarantee 
    the Quality-of-Service requirements.
</code></pre>
<p>Arguments:</p>
<pre><code> channelPri -- channel gain of the primary user
 channelSec -- channel gain of the secondary user.
 snrValuesdB -- SNR values in dB.
 powerPrimary --  power coefficient allocated to the Primary user.
 powerSecondary --  power coefficient allocated to the Secondary user.
 target_RatePri -- target rate of the primary user.
</code></pre>
<p>Return:
</p>
<pre><code> inst_rate_primary -- instantaneous achievable rate of the primary user.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_Instantaneous_Rate_Primary(channelPri,channelSec,snrValuesdB,powerPrimary,powerSecondary,target_RatePri):
   &#39;&#39;&#39;Returns the instantaneous achievable rate of the primary user for all values of SNR in dB.

      `sinr_primary:` generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the primary user based on NOMA.

      `inst_rate_primary:` calculates instantaneous rate of the primary user based on sinr_primary.

            If the calculated instantaneous rate does not reach the rate desired by the user, OMA is used in order to guarantee 
            the Quality-of-Service requirements. 

     Arguments:

         channelPri -- channel gain of the primary user
         channelSec -- channel gain of the secondary user.
         snrValuesdB -- SNR values in dB.
         powerPrimary --  power coefficient allocated to the Primary user.
         powerSecondary --  power coefficient allocated to the Secondary user.
         target_RatePri -- target rate of the primary user.
    Return:   
         
         inst_rate_primary -- instantaneous achievable rate of the primary user.
   &#39;&#39;&#39;
   for sn in range(0,len(snrValuesdB)):    

      sinr_primary[sn] = (snr_linear[sn]*channelPri*powerPrimary) / (snr_linear[sn]*channelSec*powerSecondary  + 1)
      inst_rate_primary[sn] = np.log(1+sinr_primary[sn]) # Instantaneous achievable rate of primary user NOMA

      if inst_rate_primary[sn] &lt; target_RatePri: 
         sinr_primary[sn] = (snr_linear[sn]*channelPri)
         inst_rate_primary[sn] = 0.5*np.log(1+sinr_primary[sn]) # Instantaneous achievable rate of primary user OMA
   return inst_rate_primary</code></pre>
</details>
</dd>
<dt id="pauavnoma.calculate_Instantaneous_Rate_Secondary"><code class="name flex">
<span>def <span class="ident">calculate_Instantaneous_Rate_Secondary</span></span>(<span>channelSec, snrValues, powerSecondary)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the instantaneous achievable rate of the secondary user for all values of SNR in dB.</p>
<p><code>sinr_secondary:</code> generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the secondary user based on NOMA.</p>
<p><code>inst_rate_secondary:</code> calculates instantaneous rate of the secondary user based on sinr_secondary.</p>
<p>Arguments:</p>
<pre><code> channelSec -- channel gain of the secondary user.
 snrValues -- SNR values in dB.
 powerSecondary --  power coefficient allocated to the Secondary user.
</code></pre>
<p>Return:
</p>
<pre><code> inst_rate_secondary -- instantaneous achievable rate of the secondary user.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_Instantaneous_Rate_Secondary(channelSec,snrValues,powerSecondary):
   &#39;&#39;&#39;Returns the instantaneous achievable rate of the secondary user for all values of SNR in dB.

      `sinr_secondary:` generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the secondary user based on NOMA.

      `inst_rate_secondary:` calculates instantaneous rate of the secondary user based on sinr_secondary.


     Arguments:

         channelSec -- channel gain of the secondary user.
         snrValues -- SNR values in dB.
         powerSecondary --  power coefficient allocated to the Secondary user.
    Return:   
         
         inst_rate_secondary -- instantaneous achievable rate of the secondary user.   
   &#39;&#39;&#39;

   for sn in range(0,len(snrValues)):    
      sinr_secondary[sn] = (snr_linear[sn]*channelSec*powerSecondary)
      inst_rate_secondary[sn] = np.log(1+sinr_secondary[sn]) # Instantaneous achievable rate of secondary user

   return inst_rate_secondary</code></pre>
</details>
</dd>
<dt id="pauavnoma.generate_Channel"><code class="name flex">
<span>def <span class="ident">generate_Channel</span></span>(<span>s, sigma, numberUser, user_X, user_Y, uav_X, uav_Y, path_loss, uav_Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sorting channel gains of the users over Rician Fading. The channel gains are sorted to identify
the primary user and secondary user.</p>
<p><code>ch_coeff:</code> calculating channel coefficients with Random Variable Rice of mean=s and variance=sigma.</p>
<p><code>distance:</code> calculating distance between UAV and users.</p>
<p><code>h_n:</code> calculates channel coefficients based on the distance.</p>
<p><code>channelGain:</code> calculates the channel gains and sorting in descending order.</p>
<pre><code>          Primary user:  channelGain[0]   -&gt; max value

          Secondary user:  channelGain[1] -&gt; min value
</code></pre>
<p>Arguments:</p>
<pre><code> s -- non-Centrality Parameter (mean).
 sigma -- standard deviation.
 numberUser -- number of user.
 user_X -- position axis x of n-th user.
 user_Y -- position axis y of n-th user.
 uav_X -- position axis x of UAV.
 uav_Y -- position axis y of UAV.
 path_loss -- path loss exponent.
 uav_z -- UAV heigth.
</code></pre>
<p>Return:
</p>
<pre><code> channelGain -- sorted channel gain of the users.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_Channel(s,sigma,numberUser,user_X, user_Y, uav_X, uav_Y, path_loss, uav_Z):
  &#39;&#39;&#39;Returns the sorting channel gains of the users over Rician Fading. The channel gains are sorted to identify
     the primary user and secondary user.

     `ch_coeff:` calculating channel coefficients with Random Variable Rice of mean=s and variance=sigma.

     `distance:` calculating distance between UAV and users.

     `h_n:` calculates channel coefficients based on the distance.

      `channelGain:` calculates the channel gains and sorting in descending order.

                  Primary user:  channelGain[0]   -&gt; max value

                  Secondary user:  channelGain[1] -&gt; min value    

     Arguments:

         s -- non-Centrality Parameter (mean).
         sigma -- standard deviation.
         numberUser -- number of user.
         user_X -- position axis x of n-th user.
         user_Y -- position axis y of n-th user.
         uav_X -- position axis x of UAV.
         uav_Y -- position axis y of UAV.
         path_loss -- path loss exponent.
         uav_z -- UAV heigth.
    Return:   

         channelGain -- sorted channel gain of the users.             
    
  &#39;&#39;&#39;
  for uu in range(numberUser):  

      ch_coeff = np.sqrt( (np.random.normal(s,sigma)**2) + 1j*(np.random.normal(0,sigma)**2) )
      distance[uu]= np.sqrt( (user_X[uu]-uav_X)**2  + (user_Y[uu]-uav_Y)**2   + uav_Z**2  )
      h_n[uu] = np.abs(ch_coeff/np.complex(sqrt(1+(distance[uu])**path_loss),0))**2

  channelGain = sorted(h_n, reverse=True)
  return channelGain  </code></pre>
</details>
</dd>
<dt id="pauavnoma.generate_power_Coeff"><code class="name flex">
<span>def <span class="ident">generate_power_Coeff</span></span>(<span>n_users)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the power coefficient allocation of the users.
Arguments:</p>
<pre><code> n_user -- number of users.
</code></pre>
<p>Return:
</p>
<pre><code> data_power_Pri --  power coefficients of the Primary users.
 data_power_Sec --  power coefficients of the Secondary users.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_power_Coeff(n_users):
   &#39;&#39;&#39;Returns the power coefficient allocation of the users.
     Arguments:

         n_user -- number of users. 
    Return:   

         data_power_Pri --  power coefficients of the Primary users.
         data_power_Sec --  power coefficients of the Secondary users.
   &#39;&#39;&#39;

   print(&#39;WARNING: The sum of powers must be: [0 &lt;sum(power) &lt;= 1], \n AND the power of the primary user must be greater than that of the secondary in order for their QoS to be satisfied. E.g. user_1 = 0.8 and user_2 =0.2.\n&#39;)
   #(&#39;Enter the value of power coefficient allocation of the Primary User:  &#39;)
   data_power_Pri = 0.8 #float(input(&#39;--&gt; &#39;))
  # (&#39;Enter the value of power coefficient allocation of the Secondart User:  &#39;)
   data_power_Sec = 0.2 #float(input(&#39;--&gt; &#39;))
      
   return data_power_Pri, data_power_Sec</code></pre>
</details>
</dd>
<dt id="pauavnoma.parameters"><code class="name flex">
<span>def <span class="ident">parameters</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the simulation parameters.</p>
<p>Enter values for each requested parameter. The entered
values are tested to check if the parameters are viable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parameters():
   &#39;&#39;&#39;Returns the simulation parameters.

      Enter values for each requested parameter. The entered 
      values are tested to check if the parameters are viable.
   &#39;&#39;&#39;
   samples_mc = 10000 # Monte Carlo samples
   print(&#34;The greater the number of samples, the more computational time is required.&#34;)
   assert 10000&lt;=samples_mc &lt;= 1000000, &#34;Invalid quantity, the value entered must be 10000&lt;=samples_mc &lt;= 1000000.&#34;

   number_users =2
   assert number_users == 2, &#34;Number of users must be 2.&#34;  

   power_los = 1.0
   assert power_los == 1.0 or power_los == 2.0,  &#34;Invalid power of Line-of-Sigth path &amp; scattered paths.&#34;
 
   rician_factor = 6 
   assert rician_factor&gt;=0 and rician_factor &lt;=10, &#34;Invalid Rician factor, the value must be (0&lt;= value &lt;= 10)&#34;
   

   path_loss_value = 2 # Path loss exponent
   number_uav = 1      # Number of UAVs
   assert number_uav == 1, &#34;Number of UAV must be 1.&#34; 

   radius_value_uav = 1.0 # Fly trajectory of the UAV in meters
   radius_value_user= 2.0 # Distribution radius of users in the cell in meters.
   # Users&#39; Target Rate
   rate_value_primary_user = 1.0  # Target rate bits/s/Hertz  primary user
   rate_value_secondary_user = 0.5  # Target rate bits/s/Hertz  secondary users
   snr_values_dB = np.array(range(10, 51, 2))  # SNR in dB
   snr_values_linear = 10**(snr_values_dB/10)  # SNR linear

   return samples_mc, number_users, power_los, rician_factor, path_loss_value, number_uav, snr_values_dB, snr_values_linear, radius_value_uav, radius_value_user, rate_value_primary_user, rate_value_secondary_user</code></pre>
</details>
</dd>
<dt id="pauavnoma.random_Position_UAV"><code class="name flex">
<span>def <span class="ident">random_Position_UAV</span></span>(<span>numberUAV, radiusUAV)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a random UAV position based on 3D Cartesian coordinates.</p>
<pre><code>     x_r: x-axis | y_r: y-axis | z_r: heigth
</code></pre>
<p><code>theta_r:</code> randomly generates an angle
</p>
<p><code>rho_r:</code> radius in meter of fly trajectory UAV</p>
<p><code>rho_u:</code> radius in meter of the area where users are distributed</p>
<p>Arguments:</p>
<pre><code> umberUAV -- number of UAV.
 radiusUAV -- fly trajectory of the UAV in meters.
</code></pre>
<p>Return:
</p>
<pre><code> x_r, y_r, z_r -- position in the x-axis, y-axis and heigth of the UAV.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_Position_UAV(numberUAV, radiusUAV):
   &#39;&#39;&#39; Returns a random UAV position based on 3D Cartesian coordinates.

             x_r: x-axis | y_r: y-axis | z_r: heigth

    `theta_r:` randomly generates an angle  

    `rho_r:` radius in meter of fly trajectory UAV


    `rho_u:` radius in meter of the area where users are distributed

     Arguments:

         umberUAV -- number of UAV.
         radiusUAV -- fly trajectory of the UAV in meters. 
    Return:   

         x_r, y_r, z_r -- position in the x-axis, y-axis and heigth of the UAV.
  &#39;&#39;&#39;
   theta_r = (np.random.rand(numberUAV,1)*(math.pi*2))
   rho_r = radiusUAV
   x_r =  (rho_r*np.cos(theta_r))
   y_r =  (rho_r*np.sin(theta_r))
   z_r = 30.0
   return x_r, y_r, z_r     </code></pre>
</details>
</dd>
<dt id="pauavnoma.random_Position_Users"><code class="name flex">
<span>def <span class="ident">random_Position_Users</span></span>(<span>numberUsers, radiusUser)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a random ground users position based on 2D Cartesian coordinates. </p>
<pre><code>    x_u: x-axis |  y_u: y-axis | height is not considered
</code></pre>
<p><code>theta_u:</code> randomly generates an angle
</p>
<p><code>rho_u:</code> radius in meter of the area where users are distributed</p>
<p>Arguments:</p>
<pre><code> numberUsers -- number of users.
 radiusUser -- distribution radius of users in the cell in meters.
</code></pre>
<p>Return:
</p>
<pre><code> x_u, y_u -- position in the x-axis and y-axis of the n-th user.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_Position_Users(numberUsers, radiusUser):
   &#39;&#39;&#39; Returns a random ground users position based on 2D Cartesian coordinates. 

            x_u: x-axis |  y_u: y-axis | height is not considered

    `theta_u:` randomly generates an angle  

    `rho_u:` radius in meter of the area where users are distributed

     Arguments:

         numberUsers -- number of users.
         radiusUser -- distribution radius of users in the cell in meters.
    Return:   

         x_u, y_u -- position in the x-axis and y-axis of the n-th user.  

   &#39;&#39;&#39;
   theta_u = (np.random.rand(numberUsers,1))*(math.pi*2)
   rho_u = (np.sqrt(np.random.rand(numberUsers,1))*radiusUser)
   x_u = (rho_u*np.cos(theta_u))
   y_u = (rho_u*np.sin(theta_u))
   return x_u, y_u  </code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#requirement">Requirement</a></li>
<li><a href="#description-of-the-simulation-parameters">Description of the Simulation Parameters</a></li>
<li><a href="#performance-analysis-metrics">Performance analysis metrics</a></li>
<li><a href="#adaptive-algorithm-description">Adaptive Algorithm description</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pauavnoma.calculate_Instantaneous_Rate_Primary" href="#pauavnoma.calculate_Instantaneous_Rate_Primary">calculate_Instantaneous_Rate_Primary</a></code></li>
<li><code><a title="pauavnoma.calculate_Instantaneous_Rate_Secondary" href="#pauavnoma.calculate_Instantaneous_Rate_Secondary">calculate_Instantaneous_Rate_Secondary</a></code></li>
<li><code><a title="pauavnoma.generate_Channel" href="#pauavnoma.generate_Channel">generate_Channel</a></code></li>
<li><code><a title="pauavnoma.generate_power_Coeff" href="#pauavnoma.generate_power_Coeff">generate_power_Coeff</a></code></li>
<li><code><a title="pauavnoma.parameters" href="#pauavnoma.parameters">parameters</a></code></li>
<li><code><a title="pauavnoma.random_Position_UAV" href="#pauavnoma.random_Position_UAV">random_Position_UAV</a></code></li>
<li><code><a title="pauavnoma.random_Position_Users" href="#pauavnoma.random_Position_Users">random_Position_Users</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>