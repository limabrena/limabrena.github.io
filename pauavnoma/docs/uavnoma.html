<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>uavnoma API documentation</title>
<meta name="description" content="Numerical Simulation of Power allocation in UAV-NOMA System â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>uavnoma</code></h1>
</header>
<section id="section-intro">
<p>Numerical Simulation of Power allocation in UAV-NOMA System.</p>
<p>A Python 3.9 implementation of a model of wireless communication
system between an area base station and two users.
Initially, power allocation is employed manually.</p>
<p>This application can be used as a study tool to understand the
behavior of the achievable rate by two users and the influence
of the allocation of power coefficients in a UAV-NOMA system.
The communication model presented is a base of UAV-NOMA principles and
can be expanded to several other scenarios, such as massive MIMO,
full-duplex communication, and others in order to
improve the users' rate performance.</p>
<p>The user can modify parameters and analyze the system's behavior.
Based on this, new methods can be proposed to solve trajectory problems,
power allocation, decoding order and others.</p>
<p>Example: when the Rician Factor <code>K=0</code>, fading is similar to Rayleigh's.</p>
<hr>
<h2 id="requirement">Requirement</h2>
<p>The implementation requires Python 3.6+ to run.
The following libraries are required:</p>
<ul>
<li><code>numpy</code> </li>
<li><code>matplotlib.pyplot</code></li>
<li><code>math</code></li>
<li><code>random</code></li>
</ul>
<hr>
<h2 id="description-of-the-simulation-parameters">Description of the Simulation Parameters</h2>
<ul>
<li><code>N_mc</code> (integer) : Monte Carlo Samples.</li>
<li><code>N_users</code> (integer) : number of users (in our case, two users).</li>
<li><code>M_uav</code>(integer) : number of UAV
(in our case, single uav).</li>
<li><code>snr_dB</code> (array of integer, size[10:2:51]) : signal-to-noise ratio in dB.</li>
<li><code>path_loss_exp</code> (integer) : path loss exponent.</li>
<li><code>P_los</code> (float) : total power of LOS path &amp; scattered paths.</li>
<li><code>K</code> (integer) : Rician Factor.</li>
<li><code>target_rate_primary_user</code> (float) : target rate in bits/s/Hertz of primary users. </li>
<li><code>target_rate_secondary_user</code> (float) : target rate in bits/s/Hertz of secondary users. </li>
<li><code>radius_uav</code> (float) : radius in meter of fly trajectory UAV.</li>
<li><code>radius_user</code> (float) : radius of the cell of users in meters.</li>
<li><code>uav_heigth</code>(float) : UAV height.</li>
<li><code>distance</code>(array of float, size(N_users)) : distance between UAV and n-th user randomly calculated for each Monte Carlo sample. </li>
<li><code>powerCoeffPrimary</code> (float) : power coefficient allocated to the Primary user.</li>
<li><code>powerCoeffSecondary</code> (float) : power coefficient allocated to the Secondary user.</li>
<li><code>ch_coeff</code> (complex number) : channel coefficients for each user generated by Rician distribution. This can be generated randomly following
using: <code>ch_coeff=np.sqrt((np.random.normal(s,sigma)**2) + 1j*(np.random.normal(0,sigma)**2))</code>.</li>
<li><code>s</code> (float) : Non-Centrality Parameter (mean) of Rician distribution, obtained by <code>s=sqrt(K/(K+1)*P_los)</code>.</li>
<li><code>sigma</code> (float) : Standard deviation of Rician distribution, obtained by <code>sigma = P_los/sqrt(2*(K+1))</code>.</li>
<li><code>h_n</code> (array of float, size(N_users)) : channel coefficients over distance effects.</li>
<li><code>channelGain</code> (array of float, size(N_users)) : channel gain <code>abs(h_n)^2</code> sorted in descending order (primary user &gt; secondary user).</li>
</ul>
<hr>
<h2 id="performance-analysis-metrics">Performance analysis metrics</h2>
<ul>
<li>
<p><code>Outage Probability:</code> the outage probability is estimated as the ratio between the number of outage events and
the total number of Monte Carlo repetitions. An outage event happens when the supported user data rates for a particular
instantaneous channel realization is less than the target data rate. </p>
</li>
<li>
<p><code>Achievable Rate:</code> the achievable rate consists of the throughput of network users, while average achievable rate
consists of the average throughput of all network users.</p>
</li>
</ul>
<p>To plot the figures, run:</p>
<pre><code>$ python plot_figures.py
</code></pre>
<hr>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

&#34;&#34;&#34; 
   Numerical Simulation of Power allocation in UAV-NOMA System.
   
   A Python 3.9 implementation of a model of wireless communication 
   system between an area base station and two users. 
   Initially, power allocation is employed manually.

   .. include:: ./doc/documentation.md

&#34;&#34;&#34;


import random
import numpy as np
from numpy import sqrt
import math
import matplotlib.pyplot as plt

class valuesGen:
    def __init__(self):
        pass

    def init_parameters():
        &#34;&#34;&#34;
        Generates some simulation parameter.
        The user can modify the parameters to analyze the system performance
        &#34;&#34;&#34;

        samples_mc = 10000  # Monte Carlo samples
        print(
            &#34;The greater the number of samples, the more computational time is required.&#34;
        )
        assert (
            10000 &lt;= samples_mc &lt;= 1000000
        ), &#34;Invalid quantity, the value entered must be 10000&lt;=samples_mc &lt;= 1000000.&#34;

        number_users = 2
        assert number_users == 2, &#34;Number of users must be 2.&#34;

        power_los = 1.0
        assert (
            power_los == 1.0 or power_los == 2.0
        ), &#34;Invalid power of Line-of-Sigth path &amp; scattered paths.&#34;

        rician_factor = 6
        assert (
            rician_factor &gt;= 0 and rician_factor &lt;= 10
        ), &#34;Invalid Rician factor, the value must be (0&lt;= value &lt;= 10)&#34;

        path_loss_value = 2  # Path loss exponent
        number_uav = 1  # Number of UAVs
        assert number_uav == 1, &#34;Number of UAV must be 1.&#34;

        radius_value_uav = 1.0  # Fly trajectory of the UAV in meters
        radius_value_user = 2.0  # Distribution radius of users in the cell in meters.
        # Users&#39; Target Rate
        rate_value_primary_user = 1.0  # Target rate bits/s/Hertz  primary user
        rate_value_secondary_user = 0.5  # Target rate bits/s/Hertz  secondary users
        snr_values_dB = np.array(range(10, 51, 2))  # SNR in dB
        snr_values_linear = 10 ** (snr_values_dB / 10)  # SNR linear

        return (
            samples_mc,
            number_users,
            power_los,
            rician_factor,
            path_loss_value,
            number_uav,
            snr_values_dB,
            snr_values_linear,
            radius_value_uav,
            radius_value_user,
            rate_value_primary_user,
            rate_value_secondary_user,
        )

    def generate_power_coeff(n_users):
        &#34;&#34;&#34;Returns the power coefficient allocation of the users.

        Arguments:

            n_user -- number of users.

        Return:

            data_power_Pri --  power coefficients of the Primary users.

            data_power_Sec --  power coefficients of the Secondary users.
        &#34;&#34;&#34;

        print(
            &#34;WARNING: The sum of powers must be: [0 &lt;sum(power) &lt;= 1], \n AND the power of the primary user must be greater than that of the secondary in order for their QoS to be satisfied. E.g. user_1 = 0.8 and user_2 =0.2.\n&#34;
        )
        # (&#39;Enter the value of power coefficient allocation of the Primary User:  &#39;)
        data_power_Pri = 0.8  # float(input(&#39;--&gt; &#39;))
        # (&#39;Enter the value of power coefficient allocation of the Secondart User:  &#39;)
        data_power_Sec = 0.2  # float(input(&#39;--&gt; &#39;))

        return data_power_Pri, data_power_Sec

    def random_position_uav(numberUAV, radiusUAV):
        &#34;&#34;&#34;Returns a random UAV position based on 3D Cartesian coordinates.

                x_r: x-axis | y_r: y-axis | z_r: heigth

        `theta_r:` randomly generates an angle

        `rho_r:` radius in meter of fly trajectory UAV

        `rho_u:` radius in meter of the area where users are distributed

        Arguments:

            numberUAV -- number of UAV.

            radiusUAV -- fly trajectory of the UAV in meters.

        Return:

            x_r, y_r, z_r -- position in the x-axis, y-axis and heigth of the UAV.
        &#34;&#34;&#34;
        theta_r = np.random.rand(numberUAV, 1) * (math.pi * 2)
        rho_r = radiusUAV
        x_r = rho_r * np.cos(theta_r)
        y_r = rho_r * np.sin(theta_r)
        z_r = 30.0
        return x_r, y_r, z_r

    def random_position_users(numberUsers, radiusUser):
        &#34;&#34;&#34;Returns a random ground users position based on 2D Cartesian coordinates.

                x_u: x-axis |  y_u: y-axis | height is not considered

        `theta_u:` randomly generates an angle

        `rho_u:` radius in meter of the area where users are distributed

        Arguments:

            numberUsers -- number of users.

            radiusUser -- distribution radius of users in the cell in meters.

        Return:

            x_u, y_u -- position in the x-axis and y-axis of the n-th user.

        &#34;&#34;&#34;
        theta_u = (np.random.rand(numberUsers, 1)) * (math.pi * 2)
        rho_u = np.sqrt(np.random.rand(numberUsers, 1)) * radiusUser
        x_u = rho_u * np.cos(theta_u)
        y_u = rho_u * np.sin(theta_u)
        return x_u, y_u

    def generate_channel(
        s, sigma, numberUser, user_X, user_Y, uav_X, uav_Y, path_loss, uav_Z
    ):
        &#34;&#34;&#34;Returns the sorting channel gains of the users over Rician Fading. The channel gains are sorted to identify
        the primary user and secondary user.

        `ch_coeff:` calculating channel coefficients with Random Variable Rice of mean=s and variance=sigma.

        `distance:` calculating distance between UAV and users.

        `h_n:` calculates channel coefficients based on the distance.

        `channelGain:` calculates the channel gains and sorting in descending order.

            Primary user:  channelGain[0]   -&gt; max value

            Secondary user:  channelGain[1] -&gt; min value

        Arguments:

            s -- non-Centrality Parameter (mean).

            sigma -- standard deviation.

            numberUser -- number of user.

            user_X -- position axis x of n-th user.

            user_Y -- position axis y of n-th user.

            uav_X -- position axis x of UAV.

            uav_Y -- position axis y of UAV.

            path_loss -- path loss exponent.

            uav_z -- UAV heigth.

        Return:

            channelGain -- sorted channel gain of the users.

        &#34;&#34;&#34;
        # Initializing auxiliary arrays to store channel coefficients and distance between UAV and users, respectively:
        h_n = np.zeros(numberUser)
        distance = np.zeros(numberUser)
        for uu in range(numberUser):

            ch_coeff = np.sqrt(
                (np.random.normal(s, sigma) ** 2)
                + 1j * (np.random.normal(0, sigma) ** 2)
            )
            distance[uu] = np.sqrt(
                (user_X[uu] - uav_X) ** 2 + (user_Y[uu] - uav_Y) ** 2 + uav_Z ** 2
            )
            h_n[uu] = (
                np.abs(ch_coeff / np.complex(sqrt(1 + (distance[uu]) ** path_loss), 0))
                ** 2
            )

        channelGain = sorted(h_n, reverse=True)
        return channelGain

    def calculate_instantaneous_rate_primary(
        channelPri, channelSec, snrValues, powerPrimary, powerSecondary, target_RatePri
    ):
        &#34;&#34;&#34;Returns the instantaneous achievable rate of the primary user for all values of SNR in dB.

        `sinr_primary:` generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the primary user based on NOMA.

        `inst_rate_primary:` calculates instantaneous rate of the primary user based on sinr_primary.

        If the calculated instantaneous rate does not reach the rate desired by the user, OMA is used in order to guarantee
        the Quality-of-Service requirements.

        Arguments:

            channelPri -- channel gain of the primary user

            channelSec -- channel gain of the secondary user.

            snrValues -- linear SNR values.

            powerPrimary --  power coefficient allocated to the Primary user.

            powerSecondary --  power coefficient allocated to the Secondary user.

            target_RatePri -- target rate of the primary user.

        Return:

            inst_rate_primary -- instantaneous achievable rate of the primary user.
        &#34;&#34;&#34;
        sinr_primary = np.zeros(
            (len(snrValues))
        )  # Initializating auxiliary array of Signal-to-interference-plus-noise ratio experienced by the primary user.
        inst_rate_primary = np.zeros((len(snrValues)))
        for sn in range(0, len(snrValues)):

            sinr_primary[sn] = (snrValues[sn] * channelPri * powerPrimary) / (
                snrValues[sn] * channelSec * powerSecondary + 1
            )
            inst_rate_primary[sn] = np.log(
                1 + sinr_primary[sn]
            )  # Instantaneous achievable rate of primary user NOMA

            if inst_rate_primary[sn] &lt; target_RatePri:
                sinr_primary[sn] = snrValues[sn] * channelPri
                inst_rate_primary[sn] = 0.5 * np.log(
                    1 + sinr_primary[sn]
                )  # Instantaneous achievable rate of primary user OMA
        return inst_rate_primary

    def calculate_instantaneous_rate_secondary(channelSec, snrValues, powerSecondary):
        &#34;&#34;&#34;Returns the instantaneous achievable rate of the secondary user for all values of SNR in dB.

        `sinr_secondary:` generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the secondary user based on NOMA.

        `inst_rate_secondary:` calculates instantaneous rate of the secondary user based on sinr_secondary.


        Arguments:

            channelSec -- channel gain of the secondary user.

            snrValues -- linear SNR values.

            powerSecondary --  power coefficient allocated to the Secondary user.

        Return:

            inst_rate_secondary -- instantaneous achievable rate of the secondary user.
        &#34;&#34;&#34;
        sinr_secondary = np.zeros(
            (len(snrValues))
        )  # Initializating auxiliary arrays of Signal-to-interference-plus-noise ratio experienced by the secondary user.
        inst_rate_secondary = np.zeros((len(snrValues)))
        for sn in range(0, len(snrValues)):
            sinr_secondary[sn] = snrValues[sn] * channelSec * powerSecondary
            inst_rate_secondary[sn] = np.log(
                1 + sinr_secondary[sn]
            )  # Instantaneous achievable rate of secondary user

        return inst_rate_secondary

class mainStructure():
    def __init__(self):
        pass

    def main_values():
        &#34;&#34;&#34;Returns the outage probability and average achievable rate of the system
        &#34;&#34;&#34;
        # --------------- Parameters ---------------
        (
            N_mc,
            N_users,
            P_los,
            K,
            path_loss_exp,
            M_uav,
            snr_dB,
            snr_linear,
            radius_uav,
            radius_user,
            target_rate_primary_user,
            target_rate_secondary_user,
        ) = valuesGen.init_parameters()
        powerCoeffPrimary, powerCoeffSecondary = valuesGen.generate_power_coeff(N_users)

        # Fading modeled by Rician distribution
        s = np.sqrt(K / (K + 1) * P_los)  # Non-Centrality Parameter (mean)
        assert s &gt;= 0  # Non-negative
        sigma = P_los / np.sqrt(2 * (K + 1))  # Standard deviation
        assert s &gt;= 0  # Non-negative


        # Initialization of some auxiliary arrays
        out_probability_system = np.zeros((N_mc, len(snr_dB)))
        out_probability_secondary_user = np.zeros((N_mc, len(snr_dB)))
        out_probability_primary_user = np.zeros((N_mc, len(snr_dB)))
        average_rate = np.zeros((N_mc, len(snr_dB)))
        instantaneous_rate_secondary = np.zeros((N_mc, len(snr_dB)))
        instantaneous_rate_primary = np.zeros((N_mc, len(snr_dB)))

        # ------------------------------------------------------------------------------------
        for mc in range(N_mc):
            # Position
            uav_AxisX, uav_AxisY, uav_heigth = valuesGen.random_position_uav(M_uav, radius_uav)
            user_AxisX, user_AxisY = valuesGen.random_position_users(N_users, radius_user)

            # Generate channel gains
            channelGainPrimary = np.max(
                valuesGen.generate_channel(
                    s,
                    sigma,
                    N_users,
                    user_AxisX,
                    user_AxisY,
                    uav_AxisX,
                    uav_AxisY,
                    path_loss_exp,
                    uav_heigth,
                )
            )
            channelGainSecondary = np.min(
                valuesGen.generate_channel(
                    s,
                    sigma,
                    N_users,
                    user_AxisX,
                    user_AxisY,
                    uav_AxisX,
                    uav_AxisY,
                    path_loss_exp,
                    uav_heigth,
                )
            )

            # Calculating achievable rate of each user
            instantaneous_rate_primary[mc, :] = valuesGen.calculate_instantaneous_rate_primary(
                channelGainPrimary,
                channelGainSecondary,
                snr_linear,
                powerCoeffPrimary,
                powerCoeffSecondary,
                target_rate_primary_user,
            )
            instantaneous_rate_secondary[
                mc, :
            ] = valuesGen.calculate_instantaneous_rate_secondary(
                channelGainSecondary, snr_linear, powerCoeffSecondary
            )

            for sn in range(0, len(snr_dB)):
                # Calculating of outage probability of the system
                if (instantaneous_rate_primary[mc, sn] &lt; target_rate_primary_user) or (
                    instantaneous_rate_secondary[mc, sn] &lt; target_rate_secondary_user
                ):
                    out_probability_system[mc, sn] = 1
                else:
                    out_probability_system[mc, sn] = 0

                # Calculating of outage probability of the primary user
                if instantaneous_rate_primary[mc, sn] &lt; target_rate_primary_user:
                    out_probability_primary_user[mc, sn] = 1
                else:
                    out_probability_primary_user[mc, sn] = 0

                # Calculating of outage probability of the secondary user
                if instantaneous_rate_secondary[mc, sn] &lt; target_rate_secondary_user:
                    out_probability_secondary_user[mc, sn] = 1
                else:
                    out_probability_secondary_user[mc, sn] = 0

                # Calculating of average achievable rate of the system
                average_rate[mc, sn] = (
                    instantaneous_rate_primary[mc, sn]
                    + instantaneous_rate_secondary[mc, sn]
                ) / 2  # Average achievable rate in bits/s/Hz
        return (
            out_probability_system,
            out_probability_primary_user,
            out_probability_secondary_user,
            instantaneous_rate_primary,
            instantaneous_rate_secondary,
            average_rate,
            snr_dB,
        )

    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="uavnoma.mainStructure"><code class="flex name class">
<span>class <span class="ident">mainStructure</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class mainStructure():
    def __init__(self):
        pass

    def main_values():
        &#34;&#34;&#34;Returns the outage probability and average achievable rate of the system
        &#34;&#34;&#34;
        # --------------- Parameters ---------------
        (
            N_mc,
            N_users,
            P_los,
            K,
            path_loss_exp,
            M_uav,
            snr_dB,
            snr_linear,
            radius_uav,
            radius_user,
            target_rate_primary_user,
            target_rate_secondary_user,
        ) = valuesGen.init_parameters()
        powerCoeffPrimary, powerCoeffSecondary = valuesGen.generate_power_coeff(N_users)

        # Fading modeled by Rician distribution
        s = np.sqrt(K / (K + 1) * P_los)  # Non-Centrality Parameter (mean)
        assert s &gt;= 0  # Non-negative
        sigma = P_los / np.sqrt(2 * (K + 1))  # Standard deviation
        assert s &gt;= 0  # Non-negative


        # Initialization of some auxiliary arrays
        out_probability_system = np.zeros((N_mc, len(snr_dB)))
        out_probability_secondary_user = np.zeros((N_mc, len(snr_dB)))
        out_probability_primary_user = np.zeros((N_mc, len(snr_dB)))
        average_rate = np.zeros((N_mc, len(snr_dB)))
        instantaneous_rate_secondary = np.zeros((N_mc, len(snr_dB)))
        instantaneous_rate_primary = np.zeros((N_mc, len(snr_dB)))

        # ------------------------------------------------------------------------------------
        for mc in range(N_mc):
            # Position
            uav_AxisX, uav_AxisY, uav_heigth = valuesGen.random_position_uav(M_uav, radius_uav)
            user_AxisX, user_AxisY = valuesGen.random_position_users(N_users, radius_user)

            # Generate channel gains
            channelGainPrimary = np.max(
                valuesGen.generate_channel(
                    s,
                    sigma,
                    N_users,
                    user_AxisX,
                    user_AxisY,
                    uav_AxisX,
                    uav_AxisY,
                    path_loss_exp,
                    uav_heigth,
                )
            )
            channelGainSecondary = np.min(
                valuesGen.generate_channel(
                    s,
                    sigma,
                    N_users,
                    user_AxisX,
                    user_AxisY,
                    uav_AxisX,
                    uav_AxisY,
                    path_loss_exp,
                    uav_heigth,
                )
            )

            # Calculating achievable rate of each user
            instantaneous_rate_primary[mc, :] = valuesGen.calculate_instantaneous_rate_primary(
                channelGainPrimary,
                channelGainSecondary,
                snr_linear,
                powerCoeffPrimary,
                powerCoeffSecondary,
                target_rate_primary_user,
            )
            instantaneous_rate_secondary[
                mc, :
            ] = valuesGen.calculate_instantaneous_rate_secondary(
                channelGainSecondary, snr_linear, powerCoeffSecondary
            )

            for sn in range(0, len(snr_dB)):
                # Calculating of outage probability of the system
                if (instantaneous_rate_primary[mc, sn] &lt; target_rate_primary_user) or (
                    instantaneous_rate_secondary[mc, sn] &lt; target_rate_secondary_user
                ):
                    out_probability_system[mc, sn] = 1
                else:
                    out_probability_system[mc, sn] = 0

                # Calculating of outage probability of the primary user
                if instantaneous_rate_primary[mc, sn] &lt; target_rate_primary_user:
                    out_probability_primary_user[mc, sn] = 1
                else:
                    out_probability_primary_user[mc, sn] = 0

                # Calculating of outage probability of the secondary user
                if instantaneous_rate_secondary[mc, sn] &lt; target_rate_secondary_user:
                    out_probability_secondary_user[mc, sn] = 1
                else:
                    out_probability_secondary_user[mc, sn] = 0

                # Calculating of average achievable rate of the system
                average_rate[mc, sn] = (
                    instantaneous_rate_primary[mc, sn]
                    + instantaneous_rate_secondary[mc, sn]
                ) / 2  # Average achievable rate in bits/s/Hz
        return (
            out_probability_system,
            out_probability_primary_user,
            out_probability_secondary_user,
            instantaneous_rate_primary,
            instantaneous_rate_secondary,
            average_rate,
            snr_dB,
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="uavnoma.mainStructure.main_values"><code class="name flex">
<span>def <span class="ident">main_values</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the outage probability and average achievable rate of the system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main_values():
    &#34;&#34;&#34;Returns the outage probability and average achievable rate of the system
    &#34;&#34;&#34;
    # --------------- Parameters ---------------
    (
        N_mc,
        N_users,
        P_los,
        K,
        path_loss_exp,
        M_uav,
        snr_dB,
        snr_linear,
        radius_uav,
        radius_user,
        target_rate_primary_user,
        target_rate_secondary_user,
    ) = valuesGen.init_parameters()
    powerCoeffPrimary, powerCoeffSecondary = valuesGen.generate_power_coeff(N_users)

    # Fading modeled by Rician distribution
    s = np.sqrt(K / (K + 1) * P_los)  # Non-Centrality Parameter (mean)
    assert s &gt;= 0  # Non-negative
    sigma = P_los / np.sqrt(2 * (K + 1))  # Standard deviation
    assert s &gt;= 0  # Non-negative


    # Initialization of some auxiliary arrays
    out_probability_system = np.zeros((N_mc, len(snr_dB)))
    out_probability_secondary_user = np.zeros((N_mc, len(snr_dB)))
    out_probability_primary_user = np.zeros((N_mc, len(snr_dB)))
    average_rate = np.zeros((N_mc, len(snr_dB)))
    instantaneous_rate_secondary = np.zeros((N_mc, len(snr_dB)))
    instantaneous_rate_primary = np.zeros((N_mc, len(snr_dB)))

    # ------------------------------------------------------------------------------------
    for mc in range(N_mc):
        # Position
        uav_AxisX, uav_AxisY, uav_heigth = valuesGen.random_position_uav(M_uav, radius_uav)
        user_AxisX, user_AxisY = valuesGen.random_position_users(N_users, radius_user)

        # Generate channel gains
        channelGainPrimary = np.max(
            valuesGen.generate_channel(
                s,
                sigma,
                N_users,
                user_AxisX,
                user_AxisY,
                uav_AxisX,
                uav_AxisY,
                path_loss_exp,
                uav_heigth,
            )
        )
        channelGainSecondary = np.min(
            valuesGen.generate_channel(
                s,
                sigma,
                N_users,
                user_AxisX,
                user_AxisY,
                uav_AxisX,
                uav_AxisY,
                path_loss_exp,
                uav_heigth,
            )
        )

        # Calculating achievable rate of each user
        instantaneous_rate_primary[mc, :] = valuesGen.calculate_instantaneous_rate_primary(
            channelGainPrimary,
            channelGainSecondary,
            snr_linear,
            powerCoeffPrimary,
            powerCoeffSecondary,
            target_rate_primary_user,
        )
        instantaneous_rate_secondary[
            mc, :
        ] = valuesGen.calculate_instantaneous_rate_secondary(
            channelGainSecondary, snr_linear, powerCoeffSecondary
        )

        for sn in range(0, len(snr_dB)):
            # Calculating of outage probability of the system
            if (instantaneous_rate_primary[mc, sn] &lt; target_rate_primary_user) or (
                instantaneous_rate_secondary[mc, sn] &lt; target_rate_secondary_user
            ):
                out_probability_system[mc, sn] = 1
            else:
                out_probability_system[mc, sn] = 0

            # Calculating of outage probability of the primary user
            if instantaneous_rate_primary[mc, sn] &lt; target_rate_primary_user:
                out_probability_primary_user[mc, sn] = 1
            else:
                out_probability_primary_user[mc, sn] = 0

            # Calculating of outage probability of the secondary user
            if instantaneous_rate_secondary[mc, sn] &lt; target_rate_secondary_user:
                out_probability_secondary_user[mc, sn] = 1
            else:
                out_probability_secondary_user[mc, sn] = 0

            # Calculating of average achievable rate of the system
            average_rate[mc, sn] = (
                instantaneous_rate_primary[mc, sn]
                + instantaneous_rate_secondary[mc, sn]
            ) / 2  # Average achievable rate in bits/s/Hz
    return (
        out_probability_system,
        out_probability_primary_user,
        out_probability_secondary_user,
        instantaneous_rate_primary,
        instantaneous_rate_secondary,
        average_rate,
        snr_dB,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="uavnoma.valuesGen"><code class="flex name class">
<span>class <span class="ident">valuesGen</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class valuesGen:
    def __init__(self):
        pass

    def init_parameters():
        &#34;&#34;&#34;
        Generates some simulation parameter.
        The user can modify the parameters to analyze the system performance
        &#34;&#34;&#34;

        samples_mc = 10000  # Monte Carlo samples
        print(
            &#34;The greater the number of samples, the more computational time is required.&#34;
        )
        assert (
            10000 &lt;= samples_mc &lt;= 1000000
        ), &#34;Invalid quantity, the value entered must be 10000&lt;=samples_mc &lt;= 1000000.&#34;

        number_users = 2
        assert number_users == 2, &#34;Number of users must be 2.&#34;

        power_los = 1.0
        assert (
            power_los == 1.0 or power_los == 2.0
        ), &#34;Invalid power of Line-of-Sigth path &amp; scattered paths.&#34;

        rician_factor = 6
        assert (
            rician_factor &gt;= 0 and rician_factor &lt;= 10
        ), &#34;Invalid Rician factor, the value must be (0&lt;= value &lt;= 10)&#34;

        path_loss_value = 2  # Path loss exponent
        number_uav = 1  # Number of UAVs
        assert number_uav == 1, &#34;Number of UAV must be 1.&#34;

        radius_value_uav = 1.0  # Fly trajectory of the UAV in meters
        radius_value_user = 2.0  # Distribution radius of users in the cell in meters.
        # Users&#39; Target Rate
        rate_value_primary_user = 1.0  # Target rate bits/s/Hertz  primary user
        rate_value_secondary_user = 0.5  # Target rate bits/s/Hertz  secondary users
        snr_values_dB = np.array(range(10, 51, 2))  # SNR in dB
        snr_values_linear = 10 ** (snr_values_dB / 10)  # SNR linear

        return (
            samples_mc,
            number_users,
            power_los,
            rician_factor,
            path_loss_value,
            number_uav,
            snr_values_dB,
            snr_values_linear,
            radius_value_uav,
            radius_value_user,
            rate_value_primary_user,
            rate_value_secondary_user,
        )

    def generate_power_coeff(n_users):
        &#34;&#34;&#34;Returns the power coefficient allocation of the users.

        Arguments:

            n_user -- number of users.

        Return:

            data_power_Pri --  power coefficients of the Primary users.

            data_power_Sec --  power coefficients of the Secondary users.
        &#34;&#34;&#34;

        print(
            &#34;WARNING: The sum of powers must be: [0 &lt;sum(power) &lt;= 1], \n AND the power of the primary user must be greater than that of the secondary in order for their QoS to be satisfied. E.g. user_1 = 0.8 and user_2 =0.2.\n&#34;
        )
        # (&#39;Enter the value of power coefficient allocation of the Primary User:  &#39;)
        data_power_Pri = 0.8  # float(input(&#39;--&gt; &#39;))
        # (&#39;Enter the value of power coefficient allocation of the Secondart User:  &#39;)
        data_power_Sec = 0.2  # float(input(&#39;--&gt; &#39;))

        return data_power_Pri, data_power_Sec

    def random_position_uav(numberUAV, radiusUAV):
        &#34;&#34;&#34;Returns a random UAV position based on 3D Cartesian coordinates.

                x_r: x-axis | y_r: y-axis | z_r: heigth

        `theta_r:` randomly generates an angle

        `rho_r:` radius in meter of fly trajectory UAV

        `rho_u:` radius in meter of the area where users are distributed

        Arguments:

            numberUAV -- number of UAV.

            radiusUAV -- fly trajectory of the UAV in meters.

        Return:

            x_r, y_r, z_r -- position in the x-axis, y-axis and heigth of the UAV.
        &#34;&#34;&#34;
        theta_r = np.random.rand(numberUAV, 1) * (math.pi * 2)
        rho_r = radiusUAV
        x_r = rho_r * np.cos(theta_r)
        y_r = rho_r * np.sin(theta_r)
        z_r = 30.0
        return x_r, y_r, z_r

    def random_position_users(numberUsers, radiusUser):
        &#34;&#34;&#34;Returns a random ground users position based on 2D Cartesian coordinates.

                x_u: x-axis |  y_u: y-axis | height is not considered

        `theta_u:` randomly generates an angle

        `rho_u:` radius in meter of the area where users are distributed

        Arguments:

            numberUsers -- number of users.

            radiusUser -- distribution radius of users in the cell in meters.

        Return:

            x_u, y_u -- position in the x-axis and y-axis of the n-th user.

        &#34;&#34;&#34;
        theta_u = (np.random.rand(numberUsers, 1)) * (math.pi * 2)
        rho_u = np.sqrt(np.random.rand(numberUsers, 1)) * radiusUser
        x_u = rho_u * np.cos(theta_u)
        y_u = rho_u * np.sin(theta_u)
        return x_u, y_u

    def generate_channel(
        s, sigma, numberUser, user_X, user_Y, uav_X, uav_Y, path_loss, uav_Z
    ):
        &#34;&#34;&#34;Returns the sorting channel gains of the users over Rician Fading. The channel gains are sorted to identify
        the primary user and secondary user.

        `ch_coeff:` calculating channel coefficients with Random Variable Rice of mean=s and variance=sigma.

        `distance:` calculating distance between UAV and users.

        `h_n:` calculates channel coefficients based on the distance.

        `channelGain:` calculates the channel gains and sorting in descending order.

            Primary user:  channelGain[0]   -&gt; max value

            Secondary user:  channelGain[1] -&gt; min value

        Arguments:

            s -- non-Centrality Parameter (mean).

            sigma -- standard deviation.

            numberUser -- number of user.

            user_X -- position axis x of n-th user.

            user_Y -- position axis y of n-th user.

            uav_X -- position axis x of UAV.

            uav_Y -- position axis y of UAV.

            path_loss -- path loss exponent.

            uav_z -- UAV heigth.

        Return:

            channelGain -- sorted channel gain of the users.

        &#34;&#34;&#34;
        # Initializing auxiliary arrays to store channel coefficients and distance between UAV and users, respectively:
        h_n = np.zeros(numberUser)
        distance = np.zeros(numberUser)
        for uu in range(numberUser):

            ch_coeff = np.sqrt(
                (np.random.normal(s, sigma) ** 2)
                + 1j * (np.random.normal(0, sigma) ** 2)
            )
            distance[uu] = np.sqrt(
                (user_X[uu] - uav_X) ** 2 + (user_Y[uu] - uav_Y) ** 2 + uav_Z ** 2
            )
            h_n[uu] = (
                np.abs(ch_coeff / np.complex(sqrt(1 + (distance[uu]) ** path_loss), 0))
                ** 2
            )

        channelGain = sorted(h_n, reverse=True)
        return channelGain

    def calculate_instantaneous_rate_primary(
        channelPri, channelSec, snrValues, powerPrimary, powerSecondary, target_RatePri
    ):
        &#34;&#34;&#34;Returns the instantaneous achievable rate of the primary user for all values of SNR in dB.

        `sinr_primary:` generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the primary user based on NOMA.

        `inst_rate_primary:` calculates instantaneous rate of the primary user based on sinr_primary.

        If the calculated instantaneous rate does not reach the rate desired by the user, OMA is used in order to guarantee
        the Quality-of-Service requirements.

        Arguments:

            channelPri -- channel gain of the primary user

            channelSec -- channel gain of the secondary user.

            snrValues -- linear SNR values.

            powerPrimary --  power coefficient allocated to the Primary user.

            powerSecondary --  power coefficient allocated to the Secondary user.

            target_RatePri -- target rate of the primary user.

        Return:

            inst_rate_primary -- instantaneous achievable rate of the primary user.
        &#34;&#34;&#34;
        sinr_primary = np.zeros(
            (len(snrValues))
        )  # Initializating auxiliary array of Signal-to-interference-plus-noise ratio experienced by the primary user.
        inst_rate_primary = np.zeros((len(snrValues)))
        for sn in range(0, len(snrValues)):

            sinr_primary[sn] = (snrValues[sn] * channelPri * powerPrimary) / (
                snrValues[sn] * channelSec * powerSecondary + 1
            )
            inst_rate_primary[sn] = np.log(
                1 + sinr_primary[sn]
            )  # Instantaneous achievable rate of primary user NOMA

            if inst_rate_primary[sn] &lt; target_RatePri:
                sinr_primary[sn] = snrValues[sn] * channelPri
                inst_rate_primary[sn] = 0.5 * np.log(
                    1 + sinr_primary[sn]
                )  # Instantaneous achievable rate of primary user OMA
        return inst_rate_primary

    def calculate_instantaneous_rate_secondary(channelSec, snrValues, powerSecondary):
        &#34;&#34;&#34;Returns the instantaneous achievable rate of the secondary user for all values of SNR in dB.

        `sinr_secondary:` generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the secondary user based on NOMA.

        `inst_rate_secondary:` calculates instantaneous rate of the secondary user based on sinr_secondary.


        Arguments:

            channelSec -- channel gain of the secondary user.

            snrValues -- linear SNR values.

            powerSecondary --  power coefficient allocated to the Secondary user.

        Return:

            inst_rate_secondary -- instantaneous achievable rate of the secondary user.
        &#34;&#34;&#34;
        sinr_secondary = np.zeros(
            (len(snrValues))
        )  # Initializating auxiliary arrays of Signal-to-interference-plus-noise ratio experienced by the secondary user.
        inst_rate_secondary = np.zeros((len(snrValues)))
        for sn in range(0, len(snrValues)):
            sinr_secondary[sn] = snrValues[sn] * channelSec * powerSecondary
            inst_rate_secondary[sn] = np.log(
                1 + sinr_secondary[sn]
            )  # Instantaneous achievable rate of secondary user

        return inst_rate_secondary</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="uavnoma.valuesGen.calculate_instantaneous_rate_primary"><code class="name flex">
<span>def <span class="ident">calculate_instantaneous_rate_primary</span></span>(<span>channelPri, channelSec, snrValues, powerPrimary, powerSecondary, target_RatePri)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the instantaneous achievable rate of the primary user for all values of SNR in dB.</p>
<p><code>sinr_primary:</code> generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the primary user based on NOMA.</p>
<p><code>inst_rate_primary:</code> calculates instantaneous rate of the primary user based on sinr_primary.</p>
<p>If the calculated instantaneous rate does not reach the rate desired by the user, OMA is used in order to guarantee
the Quality-of-Service requirements.</p>
<h2 id="arguments">Arguments</h2>
<p>channelPri &ndash; channel gain of the primary user</p>
<p>channelSec &ndash; channel gain of the secondary user.</p>
<p>snrValues &ndash; linear SNR values.</p>
<p>powerPrimary &ndash;
power coefficient allocated to the Primary user.</p>
<p>powerSecondary &ndash;
power coefficient allocated to the Secondary user.</p>
<p>target_RatePri &ndash; target rate of the primary user.</p>
<h2 id="return">Return</h2>
<p>inst_rate_primary &ndash; instantaneous achievable rate of the primary user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_instantaneous_rate_primary(
    channelPri, channelSec, snrValues, powerPrimary, powerSecondary, target_RatePri
):
    &#34;&#34;&#34;Returns the instantaneous achievable rate of the primary user for all values of SNR in dB.

    `sinr_primary:` generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the primary user based on NOMA.

    `inst_rate_primary:` calculates instantaneous rate of the primary user based on sinr_primary.

    If the calculated instantaneous rate does not reach the rate desired by the user, OMA is used in order to guarantee
    the Quality-of-Service requirements.

    Arguments:

        channelPri -- channel gain of the primary user

        channelSec -- channel gain of the secondary user.

        snrValues -- linear SNR values.

        powerPrimary --  power coefficient allocated to the Primary user.

        powerSecondary --  power coefficient allocated to the Secondary user.

        target_RatePri -- target rate of the primary user.

    Return:

        inst_rate_primary -- instantaneous achievable rate of the primary user.
    &#34;&#34;&#34;
    sinr_primary = np.zeros(
        (len(snrValues))
    )  # Initializating auxiliary array of Signal-to-interference-plus-noise ratio experienced by the primary user.
    inst_rate_primary = np.zeros((len(snrValues)))
    for sn in range(0, len(snrValues)):

        sinr_primary[sn] = (snrValues[sn] * channelPri * powerPrimary) / (
            snrValues[sn] * channelSec * powerSecondary + 1
        )
        inst_rate_primary[sn] = np.log(
            1 + sinr_primary[sn]
        )  # Instantaneous achievable rate of primary user NOMA

        if inst_rate_primary[sn] &lt; target_RatePri:
            sinr_primary[sn] = snrValues[sn] * channelPri
            inst_rate_primary[sn] = 0.5 * np.log(
                1 + sinr_primary[sn]
            )  # Instantaneous achievable rate of primary user OMA
    return inst_rate_primary</code></pre>
</details>
</dd>
<dt id="uavnoma.valuesGen.calculate_instantaneous_rate_secondary"><code class="name flex">
<span>def <span class="ident">calculate_instantaneous_rate_secondary</span></span>(<span>channelSec, snrValues, powerSecondary)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the instantaneous achievable rate of the secondary user for all values of SNR in dB.</p>
<p><code>sinr_secondary:</code> generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the secondary user based on NOMA.</p>
<p><code>inst_rate_secondary:</code> calculates instantaneous rate of the secondary user based on sinr_secondary.</p>
<h2 id="arguments">Arguments</h2>
<p>channelSec &ndash; channel gain of the secondary user.</p>
<p>snrValues &ndash; linear SNR values.</p>
<p>powerSecondary &ndash;
power coefficient allocated to the Secondary user.</p>
<h2 id="return">Return</h2>
<p>inst_rate_secondary &ndash; instantaneous achievable rate of the secondary user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_instantaneous_rate_secondary(channelSec, snrValues, powerSecondary):
    &#34;&#34;&#34;Returns the instantaneous achievable rate of the secondary user for all values of SNR in dB.

    `sinr_secondary:` generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the secondary user based on NOMA.

    `inst_rate_secondary:` calculates instantaneous rate of the secondary user based on sinr_secondary.


    Arguments:

        channelSec -- channel gain of the secondary user.

        snrValues -- linear SNR values.

        powerSecondary --  power coefficient allocated to the Secondary user.

    Return:

        inst_rate_secondary -- instantaneous achievable rate of the secondary user.
    &#34;&#34;&#34;
    sinr_secondary = np.zeros(
        (len(snrValues))
    )  # Initializating auxiliary arrays of Signal-to-interference-plus-noise ratio experienced by the secondary user.
    inst_rate_secondary = np.zeros((len(snrValues)))
    for sn in range(0, len(snrValues)):
        sinr_secondary[sn] = snrValues[sn] * channelSec * powerSecondary
        inst_rate_secondary[sn] = np.log(
            1 + sinr_secondary[sn]
        )  # Instantaneous achievable rate of secondary user

    return inst_rate_secondary</code></pre>
</details>
</dd>
<dt id="uavnoma.valuesGen.generate_channel"><code class="name flex">
<span>def <span class="ident">generate_channel</span></span>(<span>s, sigma, numberUser, user_X, user_Y, uav_X, uav_Y, path_loss, uav_Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sorting channel gains of the users over Rician Fading. The channel gains are sorted to identify
the primary user and secondary user.</p>
<p><code>ch_coeff:</code> calculating channel coefficients with Random Variable Rice of mean=s and variance=sigma.</p>
<p><code>distance:</code> calculating distance between UAV and users.</p>
<p><code>h_n:</code> calculates channel coefficients based on the distance.</p>
<p><code>channelGain:</code> calculates the channel gains and sorting in descending order.</p>
<pre><code>Primary user:  channelGain[0]   -&gt; max value

Secondary user:  channelGain[1] -&gt; min value
</code></pre>
<h2 id="arguments">Arguments</h2>
<p>s &ndash; non-Centrality Parameter (mean).</p>
<p>sigma &ndash; standard deviation.</p>
<p>numberUser &ndash; number of user.</p>
<p>user_X &ndash; position axis x of n-th user.</p>
<p>user_Y &ndash; position axis y of n-th user.</p>
<p>uav_X &ndash; position axis x of UAV.</p>
<p>uav_Y &ndash; position axis y of UAV.</p>
<p>path_loss &ndash; path loss exponent.</p>
<p>uav_z &ndash; UAV heigth.</p>
<h2 id="return">Return</h2>
<p>channelGain &ndash; sorted channel gain of the users.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_channel(
    s, sigma, numberUser, user_X, user_Y, uav_X, uav_Y, path_loss, uav_Z
):
    &#34;&#34;&#34;Returns the sorting channel gains of the users over Rician Fading. The channel gains are sorted to identify
    the primary user and secondary user.

    `ch_coeff:` calculating channel coefficients with Random Variable Rice of mean=s and variance=sigma.

    `distance:` calculating distance between UAV and users.

    `h_n:` calculates channel coefficients based on the distance.

    `channelGain:` calculates the channel gains and sorting in descending order.

        Primary user:  channelGain[0]   -&gt; max value

        Secondary user:  channelGain[1] -&gt; min value

    Arguments:

        s -- non-Centrality Parameter (mean).

        sigma -- standard deviation.

        numberUser -- number of user.

        user_X -- position axis x of n-th user.

        user_Y -- position axis y of n-th user.

        uav_X -- position axis x of UAV.

        uav_Y -- position axis y of UAV.

        path_loss -- path loss exponent.

        uav_z -- UAV heigth.

    Return:

        channelGain -- sorted channel gain of the users.

    &#34;&#34;&#34;
    # Initializing auxiliary arrays to store channel coefficients and distance between UAV and users, respectively:
    h_n = np.zeros(numberUser)
    distance = np.zeros(numberUser)
    for uu in range(numberUser):

        ch_coeff = np.sqrt(
            (np.random.normal(s, sigma) ** 2)
            + 1j * (np.random.normal(0, sigma) ** 2)
        )
        distance[uu] = np.sqrt(
            (user_X[uu] - uav_X) ** 2 + (user_Y[uu] - uav_Y) ** 2 + uav_Z ** 2
        )
        h_n[uu] = (
            np.abs(ch_coeff / np.complex(sqrt(1 + (distance[uu]) ** path_loss), 0))
            ** 2
        )

    channelGain = sorted(h_n, reverse=True)
    return channelGain</code></pre>
</details>
</dd>
<dt id="uavnoma.valuesGen.generate_power_coeff"><code class="name flex">
<span>def <span class="ident">generate_power_coeff</span></span>(<span>n_users)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the power coefficient allocation of the users.</p>
<h2 id="arguments">Arguments</h2>
<p>n_user &ndash; number of users.</p>
<h2 id="return">Return</h2>
<p>data_power_Pri &ndash;
power coefficients of the Primary users.</p>
<p>data_power_Sec &ndash;
power coefficients of the Secondary users.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_power_coeff(n_users):
    &#34;&#34;&#34;Returns the power coefficient allocation of the users.

    Arguments:

        n_user -- number of users.

    Return:

        data_power_Pri --  power coefficients of the Primary users.

        data_power_Sec --  power coefficients of the Secondary users.
    &#34;&#34;&#34;

    print(
        &#34;WARNING: The sum of powers must be: [0 &lt;sum(power) &lt;= 1], \n AND the power of the primary user must be greater than that of the secondary in order for their QoS to be satisfied. E.g. user_1 = 0.8 and user_2 =0.2.\n&#34;
    )
    # (&#39;Enter the value of power coefficient allocation of the Primary User:  &#39;)
    data_power_Pri = 0.8  # float(input(&#39;--&gt; &#39;))
    # (&#39;Enter the value of power coefficient allocation of the Secondart User:  &#39;)
    data_power_Sec = 0.2  # float(input(&#39;--&gt; &#39;))

    return data_power_Pri, data_power_Sec</code></pre>
</details>
</dd>
<dt id="uavnoma.valuesGen.init_parameters"><code class="name flex">
<span>def <span class="ident">init_parameters</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates some simulation parameter.
The user can modify the parameters to analyze the system performance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_parameters():
    &#34;&#34;&#34;
    Generates some simulation parameter.
    The user can modify the parameters to analyze the system performance
    &#34;&#34;&#34;

    samples_mc = 10000  # Monte Carlo samples
    print(
        &#34;The greater the number of samples, the more computational time is required.&#34;
    )
    assert (
        10000 &lt;= samples_mc &lt;= 1000000
    ), &#34;Invalid quantity, the value entered must be 10000&lt;=samples_mc &lt;= 1000000.&#34;

    number_users = 2
    assert number_users == 2, &#34;Number of users must be 2.&#34;

    power_los = 1.0
    assert (
        power_los == 1.0 or power_los == 2.0
    ), &#34;Invalid power of Line-of-Sigth path &amp; scattered paths.&#34;

    rician_factor = 6
    assert (
        rician_factor &gt;= 0 and rician_factor &lt;= 10
    ), &#34;Invalid Rician factor, the value must be (0&lt;= value &lt;= 10)&#34;

    path_loss_value = 2  # Path loss exponent
    number_uav = 1  # Number of UAVs
    assert number_uav == 1, &#34;Number of UAV must be 1.&#34;

    radius_value_uav = 1.0  # Fly trajectory of the UAV in meters
    radius_value_user = 2.0  # Distribution radius of users in the cell in meters.
    # Users&#39; Target Rate
    rate_value_primary_user = 1.0  # Target rate bits/s/Hertz  primary user
    rate_value_secondary_user = 0.5  # Target rate bits/s/Hertz  secondary users
    snr_values_dB = np.array(range(10, 51, 2))  # SNR in dB
    snr_values_linear = 10 ** (snr_values_dB / 10)  # SNR linear

    return (
        samples_mc,
        number_users,
        power_los,
        rician_factor,
        path_loss_value,
        number_uav,
        snr_values_dB,
        snr_values_linear,
        radius_value_uav,
        radius_value_user,
        rate_value_primary_user,
        rate_value_secondary_user,
    )</code></pre>
</details>
</dd>
<dt id="uavnoma.valuesGen.random_position_uav"><code class="name flex">
<span>def <span class="ident">random_position_uav</span></span>(<span>numberUAV, radiusUAV)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a random UAV position based on 3D Cartesian coordinates.</p>
<pre><code>    x_r: x-axis | y_r: y-axis | z_r: heigth
</code></pre>
<p><code>theta_r:</code> randomly generates an angle</p>
<p><code>rho_r:</code> radius in meter of fly trajectory UAV</p>
<p><code>rho_u:</code> radius in meter of the area where users are distributed</p>
<h2 id="arguments">Arguments</h2>
<p>numberUAV &ndash; number of UAV.</p>
<p>radiusUAV &ndash; fly trajectory of the UAV in meters.</p>
<h2 id="return">Return</h2>
<p>x_r, y_r, z_r &ndash; position in the x-axis, y-axis and heigth of the UAV.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_position_uav(numberUAV, radiusUAV):
    &#34;&#34;&#34;Returns a random UAV position based on 3D Cartesian coordinates.

            x_r: x-axis | y_r: y-axis | z_r: heigth

    `theta_r:` randomly generates an angle

    `rho_r:` radius in meter of fly trajectory UAV

    `rho_u:` radius in meter of the area where users are distributed

    Arguments:

        numberUAV -- number of UAV.

        radiusUAV -- fly trajectory of the UAV in meters.

    Return:

        x_r, y_r, z_r -- position in the x-axis, y-axis and heigth of the UAV.
    &#34;&#34;&#34;
    theta_r = np.random.rand(numberUAV, 1) * (math.pi * 2)
    rho_r = radiusUAV
    x_r = rho_r * np.cos(theta_r)
    y_r = rho_r * np.sin(theta_r)
    z_r = 30.0
    return x_r, y_r, z_r</code></pre>
</details>
</dd>
<dt id="uavnoma.valuesGen.random_position_users"><code class="name flex">
<span>def <span class="ident">random_position_users</span></span>(<span>numberUsers, radiusUser)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a random ground users position based on 2D Cartesian coordinates.</p>
<pre><code>    x_u: x-axis |  y_u: y-axis | height is not considered
</code></pre>
<p><code>theta_u:</code> randomly generates an angle</p>
<p><code>rho_u:</code> radius in meter of the area where users are distributed</p>
<h2 id="arguments">Arguments</h2>
<p>numberUsers &ndash; number of users.</p>
<p>radiusUser &ndash; distribution radius of users in the cell in meters.</p>
<h2 id="return">Return</h2>
<p>x_u, y_u &ndash; position in the x-axis and y-axis of the n-th user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_position_users(numberUsers, radiusUser):
    &#34;&#34;&#34;Returns a random ground users position based on 2D Cartesian coordinates.

            x_u: x-axis |  y_u: y-axis | height is not considered

    `theta_u:` randomly generates an angle

    `rho_u:` radius in meter of the area where users are distributed

    Arguments:

        numberUsers -- number of users.

        radiusUser -- distribution radius of users in the cell in meters.

    Return:

        x_u, y_u -- position in the x-axis and y-axis of the n-th user.

    &#34;&#34;&#34;
    theta_u = (np.random.rand(numberUsers, 1)) * (math.pi * 2)
    rho_u = np.sqrt(np.random.rand(numberUsers, 1)) * radiusUser
    x_u = rho_u * np.cos(theta_u)
    y_u = rho_u * np.sin(theta_u)
    return x_u, y_u</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#requirement">Requirement</a></li>
<li><a href="#description-of-the-simulation-parameters">Description of the Simulation Parameters</a></li>
<li><a href="#performance-analysis-metrics">Performance analysis metrics</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="uavnoma.mainStructure" href="#uavnoma.mainStructure">mainStructure</a></code></h4>
<ul class="">
<li><code><a title="uavnoma.mainStructure.main_values" href="#uavnoma.mainStructure.main_values">main_values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uavnoma.valuesGen" href="#uavnoma.valuesGen">valuesGen</a></code></h4>
<ul class="">
<li><code><a title="uavnoma.valuesGen.calculate_instantaneous_rate_primary" href="#uavnoma.valuesGen.calculate_instantaneous_rate_primary">calculate_instantaneous_rate_primary</a></code></li>
<li><code><a title="uavnoma.valuesGen.calculate_instantaneous_rate_secondary" href="#uavnoma.valuesGen.calculate_instantaneous_rate_secondary">calculate_instantaneous_rate_secondary</a></code></li>
<li><code><a title="uavnoma.valuesGen.generate_channel" href="#uavnoma.valuesGen.generate_channel">generate_channel</a></code></li>
<li><code><a title="uavnoma.valuesGen.generate_power_coeff" href="#uavnoma.valuesGen.generate_power_coeff">generate_power_coeff</a></code></li>
<li><code><a title="uavnoma.valuesGen.init_parameters" href="#uavnoma.valuesGen.init_parameters">init_parameters</a></code></li>
<li><code><a title="uavnoma.valuesGen.random_position_uav" href="#uavnoma.valuesGen.random_position_uav">random_position_uav</a></code></li>
<li><code><a title="uavnoma.valuesGen.random_position_users" href="#uavnoma.valuesGen.random_position_users">random_position_users</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>